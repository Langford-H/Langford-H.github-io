<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>雅可比与坐标变换</title>
      <link href="2021/02/16/%E9%9B%85%E5%8F%AF%E6%AF%94%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
      <url>2021/02/16/%E9%9B%85%E5%8F%AF%E6%AF%94%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="雅可比矩阵与雅可比行列式"><a href="#雅可比矩阵与雅可比行列式" class="headerlink" title="雅可比矩阵与雅可比行列式"></a>雅可比矩阵与雅可比行列式</h1><p>本文着重探讨雅可比行列式以及雅可比矩阵在基础力学(张量分析)中的一些作用，以及作用的证明，方便之后的流体力学、连续介质力学等基础力学的推导(并不包括代数几何方面的内容)</p><h2 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h2><p>我们定义</p><script type="math/tex; mode=display">\mathcal{J} =\frac{\partial (x_1,x_2,x_3\cdots x_m)}{\partial (\xi _1,\xi_2,\xi_3\cdots \xi_n)}=\left[\begin{array}{ccc}    \frac{\partial x_1}{\partial \xi_1}&\cdots&\frac{\partial x_1}{\partial \xi_n}\\    \vdots &\ddots &\vdots \\    \frac{\partial x_m}{\partial \xi_1}&\cdots&\frac{\partial x_m}{\partial \xi_n}\end{array}\right]</script><p>上式中右侧矩阵称为雅可比矩阵，其中$x_i=x_i(\xi_1,\xi_2,\cdots,\xi_n)(i=1,2,3\cdots m)$解释为任意一个x都是关于$\xi$的函数。而雅可比矩阵的行列式就是雅可比行列式。在此处我举一个不太严谨的例子来帮助读者理解，我们都知道要表达一个一元函数在某一点处的线性逼近值，我们有它在这一点上的导数，而当我们将一元函数的概念扩大到n维空间向量函数向m维空间的另一个向量函数的映射时，它的导数就是我们的主角————雅可比矩阵。我们用具体的实例来阐释它。  </p><h2 id="雅可比矩阵在坐标变换中的使用"><a href="#雅可比矩阵在坐标变换中的使用" class="headerlink" title="雅可比矩阵在坐标变换中的使用"></a>雅可比矩阵在坐标变换中的使用</h2><p>雅可比矩阵在<strong>张量</strong>中最重要的作用就是坐标转化。取笛卡尔坐标系(记为$D$）下的一组基矢量$x^{k’}$将其记作$x^{1’},x^{2’},x^{3’}$，同时取任意坐标系(记为$K$)一组基矢量$x^i$，将其记为$x^1,x^2,x^3$，二者以角标上撇号区分，相对的每一个笛卡尔坐标基矢量都是零一坐标系下三个基矢量的函数，反之亦然，用公式表示为：</p><script type="math/tex; mode=display">x^{k'}=x^{k'}(x^1,x^2,x^3)=x^{i}</script><script type="math/tex; mode=display">x^{i}=x^i(x^{1'},x^{2'},x^{3'})=x^{k'}</script><p>当满足雅可比行列不为零时即：</p><script type="math/tex; mode=display">det(\frac{\partial x^{k'}}{\partial x^{i}})\neq0</script><script type="math/tex; mode=display">det(\frac{\partial x^{i}}{\partial x^{k'}})\neq0</script><p>就可以得到雅可比矩阵，并用来坐标转化。现有一向量在$D$下表达为$\overrightarrow{V}=(v_1’,v_2’,v_3’)=v_k’$，欲求得该向量在$K$下表示我们可以直接将其与雅可比矩阵相乘即</p><script type="math/tex; mode=display">v_i=[\frac{\partial x^{i}}{\partial x^{k'}}]\cdot v_k'</script><p>以上是两个三维坐标间的相互转化，拓展到任意维度之间的坐标转化，雅可比矩阵适用方法不变。</p><h2 id="雅可比行列式在n维空间中微元体积转化作用及其证明"><a href="#雅可比行列式在n维空间中微元体积转化作用及其证明" class="headerlink" title="雅可比行列式在n维空间中微元体积转化作用及其证明"></a>雅可比行列式在n维空间中微元体积转化作用及其证明</h2><p>再来看雅可比行列式的作用，我们现在推导n维空间中不同坐标系下的体积转化。<br>设我们在坐标系$A_1$中有基矢量$y_i$其中$(i=1,2,3\cdots n)$，而在坐标系$A_2$中有基矢量$x_j$其中$(j=1,2,3 \cdots n)$自然在坐标系$A_1$中就有单位体积元为$dy_1dy_2\cdots dy_n$那么该体积在坐标系$A_2$中到底是如何表示的呢？<br>根据上一节及全微分的推导我们有：</p><script type="math/tex; mode=display">dy_i=\frac{\partial y_i}{\partial x_j}\cdot dx_j</script><p>为了便于理解我们在此处取消爱因斯坦哑指标系数，将其以矩阵的形式展开：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    dy_1\\    dy_2\\    \vdots\\    dy_n\end{array}\right]=\left[\begin{array}{c}    \frac{\partial y_1}{\partial x_1}dx_1+\frac{\partial y_1}{\partial x_2}dx_2+\cdots+\frac{\partial y_1}{\partial x_n}dx_n\\    \frac{\partial y_2}{\partial x_1}dx_1+\frac{\partial y_2}{\partial x_2}dx_2+\cdots+\frac{\partial y_2}{\partial x_n}dx_n\\    \vdots\\    \frac{\partial y_n}{\partial x_1}dx_1+\frac{\partial y_n}{\partial x_2}dx_2+\cdots+\frac{\partial y_n}{\partial x_n}dx_n\\\end{array}\right]</script><p>我们将上式右端的$dx_i$项单独提出为雅可比矩阵点乘列向量，再向左右两端同时右乘单位矩阵则有下式</p><script type="math/tex; mode=display">\left[    \begin{array}{cccc}    dy_1&0&\cdots &0\\    0&dy_2&\cdots &0\\    \vdots&\vdots&\ddots &\vdots\\    0&0&\cdots&dy_n    \end{array}\right]=\left[\begin{array}{cccc}    \frac{\partial y_1}{\partial x_1}&\frac{\partial y_1}{\partial x_2}&\cdots&\frac{\partial y_1}{\partial x_n}\\    \frac{\partial y_2}{\partial x_1}&\frac{\partial y_2}{\partial x_2}&\cdots&\frac{\partial y_2}{\partial x_n}\\    \vdots&\vdots&\ddots&\vdots\\    \frac{\partial y_n}{\partial x_1}&\frac{\partial y_n}{\partial x_2}&\cdots&\frac{\partial y_n}{\partial x_n}\\\end{array}\right]\cdot\left[    \begin{array}{ccccc}    dx_1&0&\cdots &0\\    0&dx_2&\cdots &0\\    \vdots&\vdots&\ddots &\vdots\\    0&0&\cdots&dx_n    \end{array}\right]</script><p>再将上式每一项取行列式则有：</p><script type="math/tex; mode=display">dy_1dy_2dy_3\cdots y_n=\|\frac{\partial y_i}{\partial x_j}\|dx_1dx_2dx_3\cdots dx_n</script><p>在这里笔者用$|\frac{\partial y_i}{\partial x_j}|$指代了雅可比行列式的绝对值。据此我们可以看到n维中两坐标系微元体积是由雅可比行列式相连接起来的。  </p><p><strong>注意</strong>这里的体积转化涉及两个问题，一是由于微元体积大小不存在负数，雅可比行列式必须要取绝对值，二是这里的转化不能再像雅可比矩阵中任意维度之间随意转化，而是必须在同一维度下转化。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 张量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与Github(1)</title>
      <link href="2021/02/04/Git-and-Github/"/>
      <url>2021/02/04/Git-and-Github/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Git，什么又是Github？"><a href="#什么是Git，什么又是Github？" class="headerlink" title="什么是Git，什么又是Github？"></a>什么是Git，什么又是Github？</h1><h2 id="先说Git"><a href="#先说Git" class="headerlink" title="先说Git"></a>先说Git</h2><p>与众人所熟知的githb不一样，git是一个<strong>软件</strong>，就如同你装在计算机里运行的所有其他软件一样，这是一个伟大的发明创造。</p><h3 id="起源、定义"><a href="#起源、定义" class="headerlink" title="起源、定义"></a>起源、定义</h3><p>git的创造者是Linus Benedict Torvalds， 林纳斯先生的另一伟大创造就是Linux系统，而我们的主角Git也与Linux有着很深的联系，Git是为Linux专门打造的版本控制器。<br>综上我们现在有两个问题，什么是版本控制器？为什么Linux需要这个玩意？ </p><h4 id="先来解决第一个文题：什么是版本控制器？"><a href="#先来解决第一个文题：什么是版本控制器？" class="headerlink" title="先来解决第一个文题：什么是版本控制器？"></a>先来解决第一个文题：什么是版本控制器？</h4><p>版本控制器统称VCS(version control system)顾名思义，它就是用来控制版本的。如果你有玩过单机版RPG游戏，那么你一定会懂，在每次面对强大的boss时，你首先需要做的就是存档，当boss战对自己不利，或是消耗太多时，为了避免死亡，你可以选择读档，从之前你的存档处开始，既避免了死亡的惩罚，又不用像之前一样解决小怪。<br>版本控制器就是文件版的存档，当你在自己的计算机上完成某一个项目时，你可以借助VCS来实现版本的储存迭代，它会记录下每一次的版本内容，提交时间，你可以选择从现在跳回(Git中成为回滚)之前你储存的<strong>任何</strong>一个版本。<br>要做到以上，通常我们会这么做<img src="/2021/02/04/Git-and-Github/example.png" class title="example"><br>这样会导致文件乱七八糟，如果起名不规则，还会导致文件错乱。但如果运用Git，文件夹中只会有一个文件，但却保存所有的文件版本。以上过程都在你自己的本地计算机中进行，叫做local VCS，Git当然能做到，但它做到的不仅于此。<br><img src="/2021/02/04/Git-and-Github/Lvcs.png" class title="Local vcs示意图，引自[3]">  </p><h4 id="我们先解决第二个问题：为什么Linux需要Git？"><a href="#我们先解决第二个问题：为什么Linux需要Git？" class="headerlink" title="我们先解决第二个问题：为什么Linux需要Git？"></a>我们先解决第二个问题：为什么Linux需要Git？</h4><p>我在此对Linux不多作介绍，读者若对此没有概念，那请 <strong><em>一定</em></strong> 学习有关于它的相关资料，Linux是开源的操作系统，既然是开源的就会有杰出的程序员、黑客为它做出贡献，但是这就涉及到一个问题，我们该如何将这些代码片段合成来实现Linux的更新呢？原来的方法，是由林纳斯手动填补，但这样效率低下，重复劳动大，自2002年起，Linux开始使用Bitkeeper(一个商用软件)作为版本控制器，来实现版本更新，这是怎么实现的？我们借此机会介绍版本控制器的另外两种模式：Centralized VCS 和 Distributed VCS。<br>Centralize VCS由一个数据中心和多个开发者构成，所有的数据、文件等都存储且仅存储在数据中心中，开发者负责对数据中心中的文件进行创建debug等。这样的好处是管理数据中心者具有绝对的权限，他可以指定每一个开发者的权限，设定他能看到多少内容。但这样做却冒着巨大的风险，一旦数据中心遭到攻击或是出现系统故障，所有人的工作都有在一瞬间化泡影的风险。<img src="/2021/02/04/Git-and-Github/Cvcs.png" class title="Centralized vcs示意图，引自[3]">Distributed VCS填补了这样的问题。<br>它将原本的Local VCS与Centralized VCS相结合，它在每个人的计算机包括中心数据库上都建立了数据库，存放了自初始到最终版本中每一个文件版本，每个人都可以将自己的工作发布上传到中心数据库，看到文件更新的人都可以从数据中心下载保存在自己的计算机之中，在此基础上再做贡献。<br><img src="/2021/02/04/Git-and-Github/Dvcs.png" class title="Distributed vcs示意图，引自[3]">Git就是帮助我们实现这一切的软件，而我们使用Git上传到的数据中心，就是大名鼎鼎的Github。<br>回到那段历史，Bitkeeper一直为Linux提供服务，直到2005年，该公司与Linux社区一众黑客决裂，相传原因是有人尝试对Bitkeeper进行破解(就是把人家的正版软件盗版化。顺带一提，Bitkeeper一直无偿为Linux社区提供服务。)没办法，社区们的诸位以林纳斯先生为首，于2005年推出了Git，来帮助Linux进行版本更新，代码补充。今天，Git不再单单是Linux的专属软件，它为windows、Linux、Mac等系统提供 <strong><em>无偿的、开源的服务</em></strong>，Git一经推出迅速占领了VCS的市场，随着Github的面世，Git的用户数量再次获得了爆炸性的增长。2016年，原本作为商业软件的Bitkeeper，宣布对外开源。<br>参考资料：<br>[1]bitkeeper官网： <a href="https://www.bitkeeper.org/">https://www.bitkeeper.org/</a><br>[2]Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a><br>[3]<strong>Progit</strong> written by Scott Chacon and Ben Straub(该书可以免费在Git官网上下载，文中思维导图均引自此书)</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
